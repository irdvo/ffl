#summary Adler32 Algorithm
=== Module Description ===
The a32 module implements the Adler32 algorithm.

=== Module Words ===
==== Adler32 Structure ====
*a32%* ( -- n )
 Get the required space for an Adler32 variable
==== Adler32 variable creation, initialisation and destruction ====
*a32-init* ( a32 -- )
 Initialise the Adler32 variable
*a32-create* ( "{{{<}}}spaces{{{>}}}name" -- ; -- a32 )
 Create a named Adler32 variable in the dictionary
*a32-new* ( -- a32 )
 Create a new Adler32 variable on the heap
*a32-free* ( a32 -- )
 Free the Adler32 variable from the heap
==== Member word ====
*a32-length@* ( a32 -- u )
 Get the length of the sum
==== Adler32 words ====
*a32-reset* ( a32 -- )
 Reset the Adler32 state
*a32-update* ( c-addr u a32 -- )
 Update the Adler32 with more data c-addr u
*a32-finish* ( a32 -- u )
 Finish the Adler32 calculation, return the result u
*a32^combine* ( a32 a32 -- u )
 Combine the twee Addler32 sums and return the combined sum u
*a32+to-string* ( u -- c-addr u )
 Convert the Adler32 result to a string, using the pictured output area
==== Inspection ====
*a32-dump* ( a32 -- )
 Dump the Adler32 variable
=== Examples ===
{{{
include ffl/a32.fs


\ Create an Adler32 variable ad1 in the dictionary

a32-create ad1

\ Update the variable with data

s" The quick brown fox jumps over the lazy dog" ad1 a32-update

\ Finish the Adler32 calculation resulting in unsigned 32 bit word
\ on the stack representing the value

ad1 a32-finish

\ Convert the value to a hex string and print

a32+to-string type cr



\ Create an Adler32 variable on the heap

a32-new value ad2

\ Update the variable with multiple data

s" The quick brown fox " ad2 a32-update
s" jumps over the lazy dog" ad2 a32-update

\ Finish the calculation

ad2 a32-finish

\ Convert the value to a hex string and print

a32+to-string type cr

\ Free the variable from the heap

ad2 a32-free
}}}
----
Generated by *ofcfrth-0.10.0*
